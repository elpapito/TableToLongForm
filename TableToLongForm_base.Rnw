\documentclass[a4paper]{article}
\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}
\addtolength{\textwidth}{.8in}
\addtolength{\voffset}{-.8in}
\addtolength{\textheight}{1.2in}
\usepackage{noweb}
\noweboptions{english}
\usepackage{xcolor}
\usepackage[colorlinks]{hyperref}
\hypersetup{linkcolor=blue!40!black,
            citecolor=green!40!black,
            filecolor=cyan!40!black,
            urlcolor=magenta!40!black}
\usepackage{graphicx}
\usepackage{natbib}
\begin{document}
\renewcommand\abstractname{\large Abstract}
%-----------------------------------------------------------------------
\title{\textbf{TableToLongForm}\\
  Literate Program}
\author{\textit{Jimmy Oh}\\
  [12pt] Department of Statistics\\
  University of Auckland}
\date{}
\maketitle
\codemargin=24pt
\begin{center}
Corresponds to R Package Version 1.3.1 (pre-release)
\end{center}
\begin{abstract}\normalsize
  TableToLongForm automatically converts hierarchical Tables intended
  for a human reader into a simple LongForm Dataframe that is machine
  readable. It does this by recognising positional cues present in the
  hierarchical Table (which would normally be interpreted visually by
  the human brain) to decompose, then reconstruct the data into a
  LongForm Dataframe. This is the Literate Program for TableToLongForm
  and contains the entirety of the code with accompanying
  documentation.
\end{abstract}
\tableofcontents

\subsection*{On Literate Programs}
\label{sec:literate.program}
This software is presented as a \emph{literate program} written in the
\emph{noweb} format (\citealt{noweb}). It serves as both the
documentation and container of the literate program. The \verb|noweb|
file can be used to produce both the \emph{literate document} and the
executable code.

The literate document is separated into \emph{documentation chunks}
and named \emph{code chunks}. Each \emph{code chunk} can contain code
directly, or contain references to other \emph{code chunks} which act
as placeholders for the contents of the respective \emph{code
  chunk}. The name of each \emph{code chunk} should serve as a short
description of the code it contains. Thus each \emph{code chunk}
provides an overview of its purpose by either directly containing
code, or by containing the names of other \emph{code chunks}. The
reader is then free to delve deeper into the respective \emph{code
  chunks} if desired.

\section{Introduction}
\label{sec:introduction}
lorem ipsum
% This doc for code
% Direct to Tech Report for a less technical introduction

\newpage
\section{Code Overview}
\label{sec:code.overview}
Unless the Table is horrible beyond mortal imagination, it should have
some kind of pattern, such that a human will be able to discern the
structure and hence understand the data it represents. This code
attempts to algorithmically search for such patterns, discern the
structure, then reconstruct the data into a LongForm Dataframe.

The task can be seen to consist of three phases:
\begin{itemize}
\item Phase One is Identification, which involves identifying the rows
  and columns where the labels and the data can be found.
\item Phase Two is Discerning the Parentage, which involves
  identifying the hierarchical structure of the data, based on the row
  and column labels.
\item Phase Three is Reconstruction, where we use what we've found in
  the first two phases to reconstruct the data into a LongForm
  Dataframe.
\end{itemize}
<<TableToLongForm.R>>=
<<document header>>
<<Front End>>
<<Back End>>
<<Identification>>
<<Discern Parentage>>
<<Reconstruction>>
@

We place a document header at the top of the extracted code to
encourage people to read the literate description rather than
attempting to study the code alone.
<<document header>>=
##----------------------------------------------------------------------
## The code in this .R file is machine generated from the literate
##  program, TableToLongForm.Rnw
## Documentation can be found in the literate description for this
##  program, TableToLongForm.pdf
##----------------------------------------------------------------------
@

\subsection{Front End}
\label{sec:front.end}
The main function \verb|TableToLongForm| is defined here. For most
users this is the only function they will call. The arguments are as
follows:

\begin{description}
\item[Table] the Table to convert, given as a \verb|character matrix|.
  Also accepts a \verb|data.frame|, which is coerced to a \verb|matrix|
  with a warning.
\item[IdentResult] an optional \verb|list| specifying the locations of
  the various elements of the \verb|Table|. By default this is
  automatically generated but it can be specified manually where the
  automatic detection fails.
\item[fulloutput] if \verb|TRUE|, returns a \verb|list| containing
  additional information primarily useful for diagnostic
  purposes. Otherwise, and by default, the function only returns the
  converted \verb|data.frame| object.
\item[diagnostics] a \verb|character vector| specifying the name of
  the file diagnostic output will be written to. Can also be
  \verb|TRUE|, in which case the file name will be the name of the
  object specified in \verb|Table|.
\end{description}

This function handles some busy-work, such as coercing the
\verb|Table| to a \verb|matrix| (with a warning) and setting up the
diagnostics output file. It then calls \verb|ReconsMain| which handles
the real meat of the conversion.

In the package version of TableToLongForm, this is the only function
that is exported, the rest are hidden in the package namespace (which
is still accessible, just not as easily). If sourcing in the raw .R
file, the majority of the supporting functions are not hidden and can
be accessed directly from the Global Environment.
<<Front End>>=
TableToLongForm =
  function(Table, IdentResult = NULL,
           IdentPrimary = "combound",
           IdentAuxiliary = "sequence",
           ParePreRow = NULL,
           ParePreCol = c("mismatch", "misalign", "multirow"),
           fulloutput = FALSE,
           diagnostics = FALSE, diagnostics.trim = TRUE){
    <<Check Table arg>>
    <<Setup diagnostics file>>
    fullout = ReconsMain(matFull = Table, IdentResult,
      IdentPrimary, IdentAuxiliary, ParePreRow, ParePreCol)
    if(fulloutput) fullout else fullout$datafr
  }
@

<<Check Table arg>>=
if(is.data.frame(Table)){
  warning("Table supplied is a data.frame.\n",
          "TableToLongForm is designed for a character matrix.\n",
          "The data.frame is being coerced to a matrix but this\n",
          "may lead to unexpected results.",
          immediate. = TRUE)
  Table = as.matrix(Table)
}
if(!is.matrix(Table))
  stop("Table argument must be a matrix or a data.frame")
@ 

<<Setup diagnostics file>>=
if(diagnostics != FALSE){
  if(!is.character(diagnostics))
    diagnostics = deparse(substitute(Table))
  assign("TCRunout", file(paste0(diagnostics, ".TCRunout"), "w"),
         envir = TTLFBaseEnv)
  assign("TCtrim", diagnostics.trim, envir = TTLFBaseEnv)
  on.exit({
    with(TTLFBaseEnv, {
      close(TCRunout)
      rm(TCRunout)
      rm(TCtrim)
    })
  })
}
@ 

\subsection{Back End}
\label{sec:back.end}
Various code, mainly to help produce diagnostic output, can be ignored
by most users.
<<Back End>>=
<<BErbinddf>>
<<BEprintplist>>
<<BEattrLoc>>
<<BETCRsink>>
<<BETTLFalias>>
@

\paragraph{rbinddf}
An \verb|rbind| method to handle data.frames with differing column
names. Does not check if arguments are actually data.frames, so can
break easily.
<<BErbinddf>>=
rbinddf =
  function(..., deparse.level = 0){
    bindlist = list(...)
    nameunion = NULL
    for(j in 1:length(bindlist))
      nameunion = union(nameunion, colnames(bindlist[[j]]))
    for(j in 1:length(bindlist)){
      curdf = bindlist[[j]]
      namediff = setdiff(nameunion, colnames(curdf))
      matdummy = matrix(NA, nrow = nrow(curdf), ncol = length(namediff),
        dimnames = list(NULL, namediff))
      bindlist[[j]] = cbind(curdf, matdummy)
    }
    outdf = do.call(rbind,
      c(bindlist, list(deparse.level = deparse.level)))
    for(j in 1:ncol(outdf))
      if(mode(outdf[,j]) == "character") outdf[,j] = factor(outdf[,j])
    outdf
  }
@ %def rbinddf

\paragraph{print.plist}
A print method for class \verb|plist|, which are nested lists with a
numeric vector at the lowest level; \verb|print.default| is rather
inefficient in displaying such nested lists.
<<BEprintplist>>=
print.plist =
  function(x, ...){
    plistC = function(plist){
      pLoc = attr(plist, "Loc")
      if(is.list(plist)){
        namevec = names(plist)
        if(!is.null(pLoc))
          namevec = paste0(names(plist),
            " (", pLoc[,"rows"], ", ", pLoc[,"cols"], ")")
        namelist = as.list(namevec)
        for(i in 1:length(namelist))
          namelist[[i]] =
            c(paste("+", namelist[[i]]),
              paste("-", plistC(plist[[i]])))
        do.call(c, namelist)
      } else{
        if(!is.null(names(plist))){
          namevec = names(plist)
          if(!is.null(pLoc))
            namevec = paste0(names(plist),
              " (", plist, ", ", pLoc[,"cols"], ")")
          paste("+", namevec)
        } else paste(plist, collapse = " ")
      }
    }
  
    cat(plistC(x), sep = "\n")
  }
@ 

\paragraph{attrLoc}
A function for creating a \verb|plist| object and binding location
information (rows and cols) to it.
<<BEattrLoc>>=
attrLoc =
  function(plist, rows = NULL, cols = NULL){
    attr(plist, "Loc") = cbind(rows, cols)
    class(plist) = "plist"
    plist
  }
@ %def attrLoc

\paragraph{TCRsink}
Sinks the output to \verb|TCRunout| for diagnostic output. Requires
the existence of \verb|TCRunout| which is created by the main function
\verb|TableToLongForm| when \verb|diagnostics = TRUE|.

Spaces may be introduced by \verb|match.call|, thus any spaces in the
args of \emph{variables to sink} (that is, the arguments supplied via
\verb|...|) are removed without warning.

We also create the \verb|TTLFBaseEnv| here, which is currently only
used to temporarily store \verb|TCRunout|.
<<BETCRsink>>=
TCRsink =
  function(ID, ...)
  if(exists("TCRunout", envir = TTLFBaseEnv)){
    varlist = list(...)
    names(varlist) = gsub(" ", "", as.character(match.call()[-(1:2)]))
    TCtrim = get("TCtrim", envir = TTLFBaseEnv)
    with(TTLFBaseEnv, sink(TCRunout))
    for(i in 1:length(varlist)){
      cat("###TCR", ID, names(varlist)[i], "\n")
      curvar = varlist[[i]]
      if(TCtrim == TRUE){
        curvar = head(curvar)
        if(is.matrix(curvar) || is.matrix(curvar))
          if(ncol(curvar) > 6)
            curvar = curvar[,1:6]
      }
      print(curvar)
    }
    sink()
  }
TTLFBaseEnv = new.env()
@ %def TCRsink TTLFBaseEnv

\paragraph{TTLFalias}
Should add a check to aliasAdd for existing rows with same alias (and
same Type, probably ok to allow same alias for different Types).
<<BETTLFalias>>=
with(TTLFBaseEnv, {aliasmat = NULL})
TTLFaliasAdd =
  function(Type, Fname, Falias, Author = "", Description = "")
  assign("aliasmat",
         rbind(get("aliasmat", envir = TTLFBaseEnv),
               c(Type = Type, Name = Fname, Alias = Falias,
                 Author = Author, Description = Description)),
         envir = TTLFBaseEnv)

TTLFaliasGet =
  function(Type, Falias){
    aliasmat = get("aliasmat", envir = TTLFBaseEnv)
    matchRow = which(aliasmat[,"Type"] == Type &
      aliasmat[,"Alias"] == Falias)
    if(length(matchRow) == 1)
      aliasmat[matchRow,"Name"]
    else stop("Invalid algorithm specified for ", Type)
  }

TTLFaliasList =
  function(){
    aliasmat = get("aliasmat", envir = TTLFBaseEnv)
    Types = unique(aliasmat[,"Type"])
    for(Type in Types){
      cat("==Type: ", Type, "==\n", sep = "")
      Algos = aliasmat[aliasmat[,"Type"] == Type,,drop=FALSE]
      for(i in 1:nrow(Algos))
        cat("Name: ", Algos[i, "Name"], "\n",
            "Alias: ", Algos[i, "Alias"], "\n",
            "Author: ", Algos[i, "Author"], "\n",
            "Description: ", Algos[i, "Description"], "\n\n",
            sep = "")
    }
  }
  
@ %def TTLFaliasAdd TTLFaliasGet

\section{Identification}
\label{sec:identification}
The purpose of \textbf{Identification} is to identify where in the
Table the data is found and where the accompanying labels are, while
ignoring any extraneous information we do not want. The output is the
\verb|IdentResult|, a list containing two elements, \verb|rows| and
\verb|cols|, each of which is a list containing these two elements:
\begin{description}
\item[label] - a vector of the rows or columns where the labels are
  found.
\item[data] - a vector of the rows or columns where the data are
  found.
\end{description}

It is intended for this procedure to involve a number of
Identification algorithms that are used for a high degree of
reliability and flexibility, but at this stage there is only a single
Primary algorithm, supplemented by a single Auxiliary algorithm.

We separate the Identification functions into three groups.
\begin{description}
\item[Ident Primary] contain Primary Ident algorithms, of which one is
  chosen when calling \verb|TableToLongForm|.
\item[Ident Auxiliary] contain Auxiliary Ident algorithms, of which
  any combination, in any order, can be chosen when calling
  \verb|TableToLongForm|. They are called after the Primary algorithm,
  to refine the \verb|IdentResult|.
\item[Ident Support] contains supporting functions called by the
  Primary and Auxiliary functions.
\end{description}

<<Identification>>=
<<Ident Primary>>
<<Ident Auxiliary>>
<<Ident Support>>
@ 

\subsection{Identification - Primary}
The Primary Ident algorithms should take a single argument,
\verb|matFull|. They should return an \verb|IdentResult|.
\label{sec:IdentPrimary}
<<Ident Primary>>=
<<Ident by Most Common Boundary>>
@

\subsubsection{Ident by Most Common Boundary}
Search for the most common start and end rows and columns (the
boundary) to find a block (rectangular region) of numbers, which is
assumed to be our table of data.
<<Ident by Most Common Boundary>>=
IdentbyMostCommonBoundary =
  function(matFull){
    <<Get Non empty rows and cols>>
    <<Call Ident MostCommonBoundary>>
    <<Construct rowslist and colslist>>
    <<Cleanup MostCommonBoundary Results>>
    list(rows = rowslist, cols = colslist)
  }
TTLFaliasAdd("IdentPrimary", "IdentbyMostCommonBoundary", "combound",
             "Base Algorithm", "Default IdentPrimary algorithm")
@

<<Get Non empty rows and cols>>=
rowNonempty = (1:nrow(matFull))[IdentNonEmpty(matFull, 1)]
colNonempty = (1:ncol(matFull))[IdentNonEmpty(matFull, 2)]
@ 

<<Call Ident MostCommonBoundary>>=
rowData = IdentMostCommonBoundary(matFull, 2)
colData = IdentMostCommonBoundary(matFull, 1)
TCRsink("CIMCB", rowData, colData)
@ 
%TCEx CIMCB rowData colData

We construct the interim \verb|rowslist| taking every non-empty row
before the most common start of the numbers block (\verb|rowData[1]|)
and assigning these to the \verb|label| region. The numbers block
(which is bounded by \verb|rowData[1]| and \verb|rowData[2]|) is
assigned to the \verb|data| region. The interim \verb|colslist| is
constructed in the same manner.
<<Construct rowslist and colslist>>=
rowslist = list(label = rowNonempty[rowNonempty < rowData[1]],
                data = rowNonempty[(rowNonempty >= rowData[1]) &
                                   (rowNonempty <= rowData[2])])
colslist = list(label = colNonempty[colNonempty < colData[1]],
                data = colNonempty[(colNonempty >= colData[1]) &
                                   (colNonempty <= colData[2])])
TCRsink("CRAC", rowslist, colslist)
@ 
%TCEx CRAC rowslist colslist

As the \verb|MostCommonBoundary| algorithm searches for the data
region, it can be conservative with respect to the rows and columns
assigned to data. Under most circumstances this causes no problems,
but in certain rare cases of mismatched column labels, there are
column labels that are outside the data region (that is, the column
label is not over the data it is the label of, hence mismatched).
To correct for this, we do the following:
\begin{enumerate}
\item If \verb|matRowLabel| isn't all empty
\item Shift any fully empty columns on the right to \verb|cols$data|
\end{enumerate}
<<Cleanup MostCommonBoundary Results>>=
matRowLabel = matFull[rowslist$data, colslist$label,drop=FALSE]
if(!all(is.na(matRowLabel)) && ncol(matRowLabel) > 1){
  RowLabelNonempty = IdentNonEmpty(matRowLabel, 2)
  if(max(RowLabelNonempty) < ncol(matRowLabel)){
    toshift = (max(RowLabelNonempty) + 1):ncol(matRowLabel)
    colslist$data = c(colslist$label[toshift], colslist$data)
    colslist$label = colslist$label[-toshift]
  }
}
@

\subsection{Identification - Auxiliary}
The Auxiliary Ident algorithms should take two arguments,
\verb|matFull| and \verb|IdentResult|. They should return an
\verb|IdentResult|.
\label{sec:IdentAuxiliary}
<<Ident Auxiliary>>=
<<Ident by Sequence>>
@

\subsubsection{Ident by Sequence}
Search for fully numeric row labels (e.g. Years) that were
misidentified as data, by checking if the numbers follow some fixed
sequence. If such a situation is found (result is not \verb|NA|), we
update \verb|IdentResult|. This is intended to be used in conjunction
with the \emph{Ident by Most Common Boundary} Primary algorithm, which
assumes numbers to be data, and not labels.

Currently the algorithm is conservative, only making the check if the
current \verb|matRowLabel| is empty (\verb|ncol = 0|, or all
\verb|NA|s), and only accepting a sequence of fixed difference, with
no gaps or jumps, e.g.
\begin{itemize}
\item 1 2 3 4, then a sequence
\item 1 2 4 5, then not a sequence
\end{itemize}
<<Ident by Sequence>>=
IdentbySequence =
  function(matFull, IdentResult)
  with(IdentResult, {
    matRowLabel = matFull[rows$data, cols$label]
    <<If empty take next column>>
    <<Check if sequence>> 
  })
TTLFaliasAdd("IdentAuxiliary", "IdentbySequence", "sequence",
             "Base Algorithm", paste("Search for fully numeric row",
             "labels (e.g. Years) that were misidentified as data"))
@

<<If empty take next column>>=
if(all(is.na(matRowLabel))){
  cols$label = cols$data[1]
  cols$data = cols$data[-1]
  IdentbySequence(matFull, list(rows = rows, cols = cols))
}
@ 

Check to see if all diffs are equal, but original values are not. If
it is, we have a sequence and we return an updated \verb|IdentResult|.
<<Check if sequence>>=
else{
  matRowLabel = suppressWarnings(as.numeric(matRowLabel))
  if(length(unique(matRowLabel)) > 1 &&
     length(unique(diff(matRowLabel))) == 1)
    list(rows = rows, cols = cols)
  else IdentResult
}
@ 

\subsection{Identification - Support}
\label{sec:IdentSupport}
Here we discuss the supporting functions called by the Primary and
Auxiliary functions. Each chunk corresponds to a separate supporting
function.
<<Ident Support>>=
<<Ident Non Empty>>
<<Ident Pattern>>
<<Ident Most Common Boundary>>
@ 

\subsubsection{IdentNonEmpty}
Given a matrix (\verb|mat|) and a margin (1 for rows, 2 for
columns), return a vector giving the indices of non-empty rows or
columns. Can specify a different empty identifying function (default
\verb|is.na|). Procedure:
\begin{enumerate}
\item Compute \verb|isnonempty|, a logical vector about whether the
  rows or cols are not empty.
\item Use \verb|which| on \verb|isnonempty| to get indices.
\end{enumerate}
<<Ident Non Empty>>=
IdentNonEmpty =
  function(mat, margin, emptyident = is.na){
    isnonempty = apply(mat, margin, function(x) !all(emptyident(x)))
    which(isnonempty)
  }
@ %def IdentNonEmpty

\subsubsection{IdentPattern}
Attempt to discern a repeating pattern in \verb|vec|, which can be a
vector of any type (which is coerced to \verb|character|). The
returned value is the grouping number for the repeating pattern, or
the length of \verb|vec| if there is no repeating pattern, e.g.
\begin{itemize}
\item \verb|vec| = 1 1 1 1, then return 1
\item \verb|vec| = 3 4 3 4, then return 2
\item \verb|vec| = 1 2 3 4, then return 4
\item \verb|vec| = 1 2 3 1, then return 4
\end{itemize}
\verb|IdentPattern| does this fairly efficiently by use of regular
expressions and \verb|match|.
<<Ident Pattern>>=
IdentPattern =
  function(vec){
    <<Look for potential repeat>>
    <<Check if pattern repeats>>
  }
@ %def IdentPattern

Look for when unique values of \verb|vec| repeat, and see if the
distance (\verb|diff|) between these are equal (hence the
\verb|unique| of the \verb|diff| result will be of length 1). If it
is, we take this as our potential repeating point and move on.

If the value does not repeat at all, \verb|diff| will return a
\verb|vector| of length 0, which is adjusted to the length of
\verb|vec|.
<<Look for potential repeat>>=
matchvec = match(vec, unique(vec))
for(i in 1:length(unique(matchvec))){
  repind = unique(diff(which(matchvec == i)))
  if(length(repind) == 0)
    repind = length(vec)
  if(length(repind) == 1)
    break
}
@ 

We combine the first \verb|repind| elements of \verb|vec| and collapse
this into a single string. A \verb|grep| is then called on the entire
\verb|vec| that has also been collapsed into a single string, checking
to see if the entire string can be matched to some repeat of the
aforementioned collapsed string of the first \verb|repind|
elements. If it can, we have a repeating pattern and thus return
\verb|repind|. Otherwise, we return the length of \verb|vec|.
<<Check if pattern repeats>>=
curseg = paste0("^(", paste(vec[1:repind], collapse = ""), ")+$")
if(length(grep(curseg, paste(vec, collapse = ""))) > 0)
  repind else length(vec)
@ 

\subsubsection{IdentMostCommonBoundary}
Search for the most common first and last rows/cols to identify a
block (rectangular region) of numbers. Procedure:
\begin{enumerate}
\item Suppose \verb|margin = 2|, then loop through each column and
  search for cells containing numbers.
\item Compute the first row with a number for each column
  (\verb|nstarts|), and do the same for the last row (\verb|nends|).
\item Return the most common first and last rows.
\end{enumerate}

<<Ident Most Common Boundary>>=
IdentMostCommonBoundary =
  function(matFull, margin){
    isnumber = suppressWarnings(apply(matFull, margin,
      function(x) which(!is.na(as.numeric(x)))))
    nstarts = table(sapply(isnumber,
      function(x) if(length(x) > 0) min(x) else NA))
    nends = table(sapply(isnumber,
      function(x) if(length(x) > 0) max(x) else NA))
    as.numeric(names(c(which.max(nstarts), which.max(rev(nends)))))
  }
@ %def IdentMostCommonBoundary

\section{Discern Parentage}
\label{sec:parentage}
The purpose of \textbf{Discern Parentage} is to understand the
hierarchical structure (the \emph{parentage}) of the row and column
labels. The output will be the \verb|rowplist| and \verb|colplist|,
the row and column parentage lists. TO DO explanation of plist.

We separate the Parentage functions into five groups.
\begin{description}
\item[Pare Pre Row] contain pre-requisite algorithms that tidy up the
  Row Labels for correct operation of the Main Parentage
  algorithm. Any combination of these algorithms, in any order, can be
  chosen when calling \verb|TableToLongForm|. The current
  implementation of TableToLongForm has no Pre Row algorithms.
\item[Pare Pre Col] contain pre-requisite algorithms that tidy up the
  Column Labels for correct operation of the Main Parentage
  algorithm. Any combination of these algorithms, in any order, can be
  chosen when calling \verb|TableToLongForm|.
\item[Pare Front] is a simple `front-end' function that makes the
  appropriate first call to \verb|PareMain|.
\item[Pare Main] contains the Main algorithm that will recursively
  call itself until the all parentage is discerned.
\item[Pare Low Level] contains low-level functions called by the Main
  function.
\end{description}

<<Discern Parentage>>=
<<Pare Pre Row>>
<<Pare Pre Col>>
<<Pare Front>>
<<Pare Main>>
<<Pare Low Level>>
@ 

\subsection{Parentage - Pre Row}
Parentage Pre Row algorithms should take two arguments, \verb|matData|
and \verb|matRowLabel|. They should return a named list containing two
elements, \verb|matData| and \verb|matRowLabel|.

The current implementation of TableToLongForm has no Pre Row
algorithms, but has support for external modules that add Pre Row
algorithms.
<<Pare Pre Row>>=
## Empty
@ 

\subsection{Parentage - Pre Col}
Parentage Pre Col algorithms should take two arguments, \verb|matData|
and \verb|matColLabel|. They should return a named list containing two
elements, \verb|matData| and \verb|matColLabel|.
<<Pare Pre Col>>=
<<Mismatched Col Labels>>
<<Misaligned Col Parent>>
<<Multirow Col Labels>>
@

\subsubsection{Case Mismatched Column Labels}
We check for any mismatched column labels by checking if there are the
same number of non-empty columns for the two subsets, and that there
are empty columns in the subsets, which together imply mismatched
column labels. If that is the case, we update our mat Subsets as
required.
\begin{table}[hbt]
  \hspace{7em}
  \begin{tabular}{| l | l |}
    \hline
    Column Label & \\
    \hline
    & 1 \\
    & 2 \\
    & 3 \\
    \hline
  \end{tabular}
  \hspace{10em}
  \begin{tabular}{| p{1.5em} | l |}
    \hline
    \multicolumn{2}{| c |}{Column Label} \\
    \hline
    & 1 \\
    & 2 \\
    & 3 \\
    \hline
  \end{tabular}
  \caption{An example of mismatched column labels. The label is in a
    different column to the data it belongs to. The algorithm can
    detect this as mismatched as they have the same number of
    non-empty columns (1), and have empty columns in each subset (seen
    easily in the left table as the 2 empty cells). Such cases can
    occur due to some misguided attempts to visually align the label
    to the data (e.g. table on the right).}
\end{table}
<<Mismatched Col Labels>>=
ParePreColMismatch =
  function(matData, matColLabel){
    colsData = IdentNonEmpty(matData, 2)
    colsLabels = IdentNonEmpty(matColLabel, 2)
    if(length(colsData) == length(colsLabels))
      if(ncol(matData) != length(colsData)){
        matColLabel = matColLabel[,colsLabels,drop=FALSE]
        matData = matData[,colsData,drop=FALSE]
      }
    list(matData = matData, matColLabel = matColLabel)
  }
TTLFaliasAdd("ParePreCol", "ParePreColMismatch", "mismatch",
             "Base Algorithm", paste("Correct for column labels",
             "not matched correctly over data (label in a",
             "different column to data)"))
@ 

\subsubsection{Case Misaligned Column Parents}
We correct for any misaligned column parents by using pattern matching
to detect parent-groupings, and then realigning the parents.
<<Misaligned Col Parent>>=
ParePreColMisaligned =
  function(matData, matColLabel){
    TCRsink("MCPBefore", matColLabel)
    for(i in 1:nrow(matColLabel)){
      currow = matColLabel[i,]
      <<Search for Pattern>>
      <<Align Column Parents>>
    }
    TCRsink("MCPAfter", matColLabel)
    list(matData = matData, matColLabel = matColLabel)
  }
TTLFaliasAdd("ParePreCol", "ParePreColMisaligned", "misalign",
             "Base Algorithm", paste("Correct for column labels",
             "not aligned correctly over data (parents not",
             "positioned on the far-left, relative to their",
             "children in the row below)"))
@
%TCEx MCPBefore matColLabel
%TCEx MCPAfter matColLabel

\begin{table}[hbt]
  \centering
  \begin{tabular}{| l | l | l | l | l | l |}
    \hline
    & Column Parent1 &  & & Column Parent2 & \\
    \hline
    Child1 & Child2 & Child3 &
    Child1 & Child2 & Child3 \\
    \hline
  \end{tabular}
  \caption{An example of misaligned column parents. For our low-level
    Parentage algorithm to work, we want the Column Parents to be in
    the left-most cell of their parent-grouping.}
  \label{tab:Pare.misaligned}
\end{table}
The value of \verb|curPattern| will be the following:
\begin{itemize}
\item If completely empty (all \verb|NA|), return \verb|NA|.
\item If any empty, check pattern of emptiness. In the above Table row
  1, this will find the pattern: NonEmpty-Empty-NonEmpty which occurs
  twice. Hence return 2.
\item Else, all cells are non-empty, check pattern of contents. In the
  above Table row 2, this will find the pattern: Child1-Child2-Child3
  which occurs twice. Hence return 2.
\end{itemize}
<<Search for Pattern>>=
curPattern =
  if(all(is.na(currow))) NA
  else if(any(is.na(currow))) IdentPattern(is.na(currow))
  else IdentPattern(currow)
@ 

For each subset of the row (based on pattern), move any empty cells
(\verb|NA|) to the end, hence aligning the non-empty cell (the parent)
to the left.
<<Align Column Parents>>=
if(!is.na(curPattern)){
  nParents = length(currow)/curPattern
  for(j in 1:nParents){
    curcols = 1:curPattern + curPattern * (j - 1)
    cursub = currow[curcols]
    currow[curcols] = c(cursub[!is.na(cursub)], cursub[is.na(cursub)])
    TCRsink("ACP", cursub, currow[curcols])
  }
  matColLabel[i,] = currow
}
@ 
%TCEx ACP cursub currow[curcols]

\subsubsection{Case Multi-row Column Labels}
It is also quite common for Col Labels that are too wide to be
physically split over multiple rows to manage the width of the
labels. For now, we simply assume that any rows that are not full (and
hence not parents) should all really be a single row of children, and
collapse these.
<<Multirow Col Labels>>=
ParePreColMultirow =
  function(matData, matColLabel){
    fullrows = apply(matColLabel, 1, function(x) all(!is.na(x)))
    if(any(diff(fullrows) > 1))
      warning("full rows followed by not full rows!")
    if(any(fullrows)){
      pastestring = ""
      pasterows = which(fullrows)
      for(i in 1:length(pasterows))
        pastestring[i] = paste0("matColLabel[", pasterows[i],
                     ",,drop=FALSE]")
      collapsedlabels =
        eval(parse(text = paste0("paste(",
                     paste(pastestring, collapse = ", "), ")")))

      TCRsink("MCLBefore", matColLabel)
      matColLabel = rbind(matColLabel[!fullrows,,drop=FALSE],
        collapsedlabels, deparse.level = 0)
      TCRsink("MCLAfter", matColLabel)
    }
    list(matData = matData, matColLabel = matColLabel)
  }
TTLFaliasAdd("ParePreCol", "ParePreColMultirow", "multirow",
             "Base Algorithm", paste("Merge long column labels",
             "that were physically split over multiple rows",
             "back into a single label"))
@
%TCEx MCLBefore matColLabel
%TCEx MCLAfter matColLabel

\subsection{Parentage - Front}
\label{sec:PareFront}
This front end function takes the \verb|matLabel|, which can be the
\verb|matRowLabel| or the transpose of the \verb|matColLabel|, and
constructs an initialising \verb|plist|, which is used to make the
first call to the Main function.
<<Pare Front>>=
PareFront =
  function(matLabel)
  PareMain(matSub = matLabel, plist =
           list(rows = 1:nrow(matLabel), cols = 1:ncol(matLabel)))
@ %def PareFront

\subsection{Parentage - Main}
\label{sec:PareMain}
The purpose of the \verb|PareMain| function is to identify (or
\emph{Discern}, to better differentiate this stage from the
\emph{Identification} stage) hierarchical relationships (the
\emph{Parentage}) in the data.

It first makes various checks for fringe cases, then calls various
detection algorithms (\verb|Pare Low Levels|) to discern the
parentage.
<<Pare Main>>=
PareMain =
  function(matSub, plist){
    <<If only one column>>
    <<If first column empty>>
    <<If only one row>>
    <<If first cell empty>>
    <<Otherwise call Pare Low Levels>>
    class(res) = "plist"
    res
  }
@ %def PareMain

If only one column is found then this means we are in the right-most
column (or there was only one column to begin with), and hence the
currently examined cells cannot be parents. We return the rows of
these children as a vector, with names that correspond to their
labels.
<<If only one column>>=
if(length(plist$cols) == 1){
  res = structure(plist$rows, .Names = matSub[plist$rows, plist$cols])
  res = attrLoc(res, cols = plist$col)
  TCRsink("IOOC", plist, res)
}
@ 
%TCEx IOOC plist res

If the first column is found to be empty, then we will shift to the
next column (which we know exists because we passed the check for only
one column).
<<If first column empty>>=
else if(all(is.na(matSub[plist$rows, plist$cols[1]]))){
  plist$cols = plist$cols[-1]
  res = PareMain(matSub, plist)
}
@ 

If only one row is found then our row is a parent to itself (we know
there are children in the row as we passed the check for only one
column). We return the row as a numeric vector, nested in a list using
correct parentage and names of the parentage within the row.
<<If only one row>>=
else if(length(plist$rows) == 1){
  res = structure(plist$rows,
    .Names = matSub[plist$rows, plist$cols[length(plist$cols)]])
  res = attrLoc(res, cols = plist$cols[length(plist$cols)])
  for(i in (length(plist$cols) - 1):1){
    res = list(res)
    names(res) = matSub[plist$rows, plist$cols[i]]
    res = attrLoc(res, rows = plist$rows, cols = plist$cols[i])
  }
  TCRsink("IOOR", plist, res)
}
@ 
%TCEx IOOR res

If the first cell is empty, after all previous checks, then this is an
unrecognised format and we return a warning message.
<<If first cell empty>>=
else if(is.na(matSub[plist$rows[1], plist$cols[1]])){
  warning("cell[1, 1] is empty")
  print(plist)
  res = NA
}
@ 

If we have passed all the checks, we can then call the Low Level
\verb|Pare| functions. We first call \verb|ByEmptyRight| to check for
\emph{empty right} situations. If none are found, it returns
\verb|NA|, in which case we try \verb|ByEmptyBelow| instead.

We then loop through each element of the returned list and call the
main function, as per the recursive nature of the function.
<<Otherwise call Pare Low Levels>>=
else{
  res = PareByEmptyRight(matSub, plist)
  if(any(is.na(res)))
    res = PareByEmptyBelow(matSub, plist)
  for(i in 1:length(res))
    res[[i]] = PareMain(matSub, res[[i]])
  res
}
@ 

\subsection{Parentage - Low Level Functions}
\label{sec:PareLowLevel}
The Low Level Parentage functions are called by the Main Parentage
function. In particular, \verb|ByEmptyRight| is always called
first. Then \verb|ByEmptyBelow| is called on the results of the above.
<<Pare Low Level>>=
<<Pare By Empty Right>>
<<Pare By Empty Below>>
@ 

\subsubsection{Pare By Empty Right}
We check to see if we have an \emph{empty right} situation. If we do
not, we return \verb|NA|.
<<Pare By Empty Right>>=
PareByEmptyRight =
  function(matSub, plist)
  with(plist,
       if(all(is.na(matSub[rows[1], cols[-1]]))){
         <<Check for Other Empty Rights>>
         <<Case Single Empty Right>>
         <<Case Multiple Empty Rights>>
         res
       } else NA)
@ %def PareByEmptyRight

\begin{table}[!h]
\begin{minipage}{0.4\linewidth}
  \begin{tabular}{| r | l | l |}
    \hline
     1 & \textbf{\textit{New Zealand}} &        \\
     2 & \textbf{Auckland}             &        \\
     3 & Accounting                    & Male   \\
     4 &                               & Female \\
     5 & Economics                     & Male   \\
     6 &                               & Female \\
     7 & Statistics                    & Male   \\
     8 &                               & Female \\
     9 & \textbf{Wellington}           &        \\
    10 & Economics                     & Male   \\
    11 &                               & Female \\
    12 & Statistics                    & Male   \\
    13 &                               & Female \\
    14 & \textbf{\textit{Australia}}   &        \\
    15 & \textbf{Sydney}               &        \\
    16 & Accounting                    & Male   \\
    17 &                               & Female \\
    18 & Economics                     & Male   \\
    19 &                               & Female \\
    \hline
  \end{tabular}
\end{minipage}
\begin{minipage}{0.6\linewidth}
  Consider the toy example on the left.
  
  In this case we do not have a simple \verb|ByEmptyRight| structure.
  We have \emph{super-parents} in the form of countries (New Zealand
  and Australia), and also \emph{parents} in the form of cities
  (Auckland, Wellington and Sydney). To handle situations such as
  this, we must \textbf{Check for Other Empty Rights}.
  
  If only a \textbf{Single Empty Right} is found, the situation is
  simple and we simply pass on the children of the single parent for
  the next iteration of \verb|PareMain|.
  
  However, if \textbf{Multiple Empty Rights} are found, we must
  identify the super-parents, and pass on the \emph{children} of these
  super-parents (which would, in turn, contain parents and their
  children) as a list, to be handled in the next iteration of
  \verb|PareMain|. In this example, we would have a list of length
  2. The first element of the list would contain the \verb|plist| with
  \verb|rows| 2 to 13 (corresponding to the children of the New
  Zealand super-parent). The second element would have \verb|rows| 15
  to 19.
\end{minipage}
\end{table}

<<Check for Other Empty Rights>>=
emptyrights = apply(matSub[rows, cols[-1],drop=FALSE], 1,
  function(x) all(is.na(x)))
rowemptyright = rows[emptyrights]
@ 

In the case of only a single empty right, we know there is only a
single parent, which is the first line. Thus we take everything except
the first line (which will be the rows of the children of this parent)
and pass this through with correct naming.
<<Case Single Empty Right>>=
if(length(rowemptyright) == 1){
  res = list(list(rows = rows[-1], cols = cols))
  names(res) = matSub[rows[1], cols[1]]
  res = attrLoc(res, rows = rows[1], cols = cols[1])
  TCRsink("CSER", res)
}
@ 
%TCEx CSER res

In the case of multiple empty rights, we first call \verb|diff| to
compute the gap in rows between the empty rights. If the value of
\verb|rowdiff[i]| is 1, this means there is no gap between the
i\textsuperscript{th} \verb|rowemptyright| and the (i + 1)
\verb|rowemptyright|. This happens with \emph{super-parents} as
described in the example above. In this case, we gather these
super-parents and ignore all other \verb|rowemptyright| (the parents
inside the super-parents will be handled at the next iteration of
\verb|PareMain|). Note, we assume there are never any
super-super-parents (i.e. we can only handle a maximum of 2-levels of
parentage in the same column).

Whether or not super-parents were identified, we compute the rows for
the children of each parent (or super-parent) identified by
\verb|rowemptyright| and pass this through as a list, with correct
naming.
<<Case Multiple Empty Rights>>=
else{
  rowdiff = diff(rowemptyright)
  if(any(rowdiff == 1))
    rowemptyright = rowemptyright[c(rowdiff == 1, FALSE)]
  
  rowstart = pmin(rowemptyright + 1, max(rows))
  rowend = c(pmax(rowemptyright[-1] - 1, min(rows)), max(rows))
  
  res = list()
  for(i in 1:length(rowstart))
    res[i] = list(list(rows = rowstart[i]:rowend[i], cols = cols))
  names(res) = matSub[rowemptyright, cols[1]]
  res = attrLoc(res, rows = rowemptyright, cols = cols[1])
  TCRsink("CMER", res)
}
@ 
%TCEx CMER res

\subsubsection{Pare By Empty Below}
We check which cells are empty below (there should be at least 1 based
on previous checks). Based on this, we compute the rows for the
children of each parent and pass this through as a list, with correct
naming.
<<Pare By Empty Below>>=
PareByEmptyBelow =
  function(matSub, plist)
  with(plist, {
    emptybelow = is.na(matSub[rows, cols[1]])
    rowstart = rows[!emptybelow]
    rowend = c(rowstart[-1] - 1, max(rows))
    res = list()
    for(i in 1:length(rowstart))
      res[i] = list(list(rows = rowstart[i]:rowend[i], cols = cols[-1]))
    names(res) = matSub[rowstart, cols[1]]
    res = attrLoc(res, rows = rowstart, cols = cols[1])
    TCRsink("PBEB", res)
    res
  })
@ %def PareByEmptyBelow
%TCEx PBEB res

\section{Reconstruction}
\label{sec:reconstruction}
We separate the Reconstruction functions into two groups.
\begin{description}
\item[Recons Main] contains the main function that is called by the
  \emph{Front End} function.
\item[Recons Low Level] contains supporting functions called by the
  \emph{Recons Main} function.
\end{description}
<<Reconstruction>>=
<<Recons Main>>
<<Recons Low Level>>
@

\subsection{Reconstruction - Main Function}
\label{sec:ReconsMain}
The \verb|ReconsMain| function is, in a manner of speaking, the true
\verb|TableToLongForm| function, as it makes the calls to
\verb|IdentMain| and \verb|PareFront|, in conjunction with its own
\verb|Recons Low Level| functions, to carry out the conversion.
<<Recons Main>>=
ReconsMain =
  function(matFull, IdentResult,
           IdentPrimary, IdentAuxiliary,
           ParePreRow, ParePreCol){
    <<Call Ident Algos>>
    <<Reconstruct Row Labels>>
    <<Reconstruct Col Labels>>
  }
@ %def ReconsMain

\begin{description}
\item[IdentPrimary] -Choose 1- Takes matFull, returns an IdentResult.
\item[IdentAuxiliary] -Choose any combination (in any order)- Takes
  matFull and IdentResult, returns adjusted IdentResult.
\end{description}

<<Call Ident Algos>>=
if(is.null(IdentResult)){
  IdentPrimary = TTLFaliasGet("IdentPrimary", IdentPrimary)
  IdentResult = do.call(IdentPrimary, list(matFull = matFull))
  if(!is.null(IdentAuxiliary))
    for(AuxAlgo in IdentAuxiliary){
      AuxAlgo = TTLFaliasGet("IdentAuxiliary", AuxAlgo)
      IdentResult = do.call(AuxAlgo,
        list(matFull = matFull, IdentResult = IdentResult))
    }
}
@ %def IdentResult

\begin{description}
\item[ParePreRow] -Choose any combination (in any order)- Takes
  matData and matRowLabel, and adjusts them as required. Current
  implementation has none.
\item[ParePreCol] -Choose any combination (in any order)- Takes
  matData and matColLabel, and adjusts them as required.
\item[ParePrimary] -No Choice- Constructs the plist. Handles Empty
  Right and Empty Below and their reduced subsets (e.g. lowest level
  child with no remaining parentage).
\end{description}

We create a subset of \verb|matFull| that contains just the Row
Labels. We also remove any columns that are completely empty
(N.B. this may no longer be necessary, need to do some testing).

We call \verb|PareFront| on our subset to discern the parentage of the
Row Labels. We then use this to reconstruct the portion of the
LongForm Dataframe relating to the Row Labels and assign this to
\verb|rowvecs|.
<<Reconstruct Row Labels>>=
matData = with(IdentResult,
  matFull[rows$data, cols$data,drop=FALSE])
matRowLabel = with(IdentResult,
  matFull[rows$data, cols$label,drop=FALSE])
if(!is.null(ParePreRow))
  for(PreAlgo in ParePreRow){
    PreAlgo = TTLFaliasGet("ParePreRow", PreAlgo)
    PreOut = do.call(PreAlgo,
      list(matData = matData, matRowLabel = matRowLabel))
    matData = PreOut$matData
    matRowLabel = PreOut$matRowLabel
  }
rowplist = PareFront(matRowLabel)
rowvecs = ReconsRowLabels(rowplist)
TCRsink("RRL", rowplist, rowvecs)
@ %def rowplist rowvecs
%TCEx RRL rowplist rowvecs

Due to the various fringe cases that exist with Col Labels, we cannot
simply call \verb|PareFront| and must instead call \verb|PareCol|.  We
then create a subset of \verb|matFull| that contains just the Col
Labels and call \verb|ReconsColLabels| which in truth reconstruct the
entire LongForm Dataframe by making use of the \verb|rowvecs|
generated above.

We grab subsets of \verb|matFull| that correspond to the Column Labels
region and the Data region.
After handling for all the different cases, we can simply transpose
our Col Labels and call \verb|PareFront| on it.
<<Reconstruct Col Labels>>=
matColLabel = with(IdentResult,
  matFull[rows$label, cols$data,drop=FALSE])
if(!is.null(ParePreCol))
  for(PreAlgo in ParePreCol){
    PreAlgo = TTLFaliasGet("ParePreCol", PreAlgo)
    PreOut = do.call(PreAlgo,
      list(matData = matData, matColLabel = matColLabel))
    matData = PreOut$matData
    matColLabel = PreOut$matColLabel
  }
colplist = PareFront(t(matColLabel))
matDataReduced = matData[unlist(rowplist),,drop=FALSE]
res = ReconsColLabels(colplist, matDataReduced, rowvecs)
TCRsink("RCL", colplist, res)
list(datafr = res, oriTable = matFull, IdentResult = IdentResult,
     rowplist = rowplist, colplist = colplist)
@
%TCEx RCL colplist res

\subsection{Reconstruction - Low Level Functions}
\label{sec:ReconsLowLevel}
The Low Level Reconstruction functions are called by the Main
Reconstruction function. In particular, \verb|ReconsRowLabels| is
always called first and its results are one of the arguments for
\verb|ReconsColLabels|, which finishes the reconstruction of the
entire LongForm Dataframe.
<<Recons Low Level>>=
<<Recons Row Labels>>
<<Recons Column Labels>>
@ 

\subsubsection{Reconstruction - Row Labels}
\label{sec:ReconsRowLabels}
\verb|ReconsRowLabels| iterates down the row parentage list
(\verb|plist|) recursively, extracting the names and using this to
construct the columns of the finished LongForm Dataframe corresponding
to the row labels. The final output is what was shown in the
\emph{Reconstruct Row Labels} chunk above as \verb|rowvecs[1:4,]|.
<<Recons Row Labels>>=
ReconsRowLabels =
  function(plist)
  if(is.list(plist)){
    rowvecs = as.list(names(plist))
    for(i in 1:length(rowvecs))
      rowvecs[[i]] = cbind(rowvecs[[i]], ReconsRowLabels(plist[[i]]))
    do.call(rbind, rowvecs)
  } else as.matrix(names(plist))
@ %def ReconsRowLabels
%TCEx RRL rowvecs[1:4,]

\subsubsection{Reconstruction - Column Labels}
\label{sec:ReconsColLabels}
As with the row labels, \verb|ReconsColLabels| iterates down the
column parentage list (\verb|plist|) recursively. We also need to
handle the parents differently from the lowest level child. The final
output is what was shown in the \emph{Reconstruct Col Labels} chunk
above as \verb|res[1:4,]|.
<<Recons Column Labels>>=
ReconsColLabels =
  function(plist, matData, rowvecs){
    <<Recons Col Parents>>
    <<Recons Col Children>>
    datfr
  }
@ %def ReconsColLabels
%TCEx RCL res[1:4,]

Any parents are used to construct additional columns of factors (the
labels of the parents) for the LongForm Dataframe, which is attached
to the portion previously constructed in \verb|ReconsRowLabels|.
<<Recons Col Parents>>=
if(is.list(plist)){
  colvecs = as.list(names(plist))
  for(i in 1:length(colvecs)){
    colvecs[[i]] = cbind(colvecs[[i]],
             ReconsColLabels(plist[[i]], matData, rowvecs))
    colnames(colvecs[[i]])[1] = "UNKNOWN"
  }
  datfr = do.call(rbinddf, colvecs)
}
@ 

For the lowest level child, we extract the relevant `data bits' from
the original table and bind it to our Dataframe, using the lowest
level child as the labels of these columns of data values.
<<Recons Col Children>>=
else{
  datbit = matData[,plist,drop=FALSE]
  TCRsink("RCC", plist, matData, datbit)
  datlist = NULL
  for(j in 1:ncol(datbit)){
    asnumer = suppressWarnings(as.numeric(datbit[,j]))
    if(all(is.na(datbit[,j])) || !all(is.na(asnumer)))
      datlist[[j]] = asnumer
    else
      datlist[[j]] = datbit[,j]
  }
  datbit = do.call(cbind, datlist)
  ## Specify row.names to avoid annoying warnings
  datfr =
    cbind(as.data.frame(rowvecs, row.names = 1:nrow(rowvecs)), datbit)
  colnames(datfr) =
    c(rep("UNKNOWN", length = ncol(rowvecs)), names(plist))
}
@ 

\section{Chunk Index}
\label{sec:chunk-index}
\nowebchunks

\section{Identifier Index}
\label{sec:identifier-index}
Numbers indicate the chunks in which the function appears.
Underline indicates the chunk where the function is defined.
\medskip

\nowebindex

\addcontentsline{toc}{section}{References}
\nocite{*}
\bibliographystyle{./elsart-harv} % elsart-harv,plain,unsrt,alpha
\bibliography{./TableToLongForm_refs}

\end{document}
